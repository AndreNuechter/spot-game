window.addEventListener('DOMContentLoaded', ()=>{ if ('serviceWorker' in window.navigator) { window.navigator.serviceWorker.register('./service-worker.js'); } }, { once: true }); if ('wakeLock' in navigator && 'request' in navigator.wakeLock) { const getWakeLock = ()=>navigator.wakeLock.request('screen'); getWakeLock(); document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'visible') { getWakeLock(); } }); } window.addEventListener('DOMContentLoaded', ()=>{ const getElementById = (id)=>document.getElementById(id); const startBtn = getElementById('start'); const board = new Array(Math.pow(7, 2)).fill(0); const mainClassList = document.querySelector('main').classList; const boardObject = getElementById('board'); const players = [ new Player('#3399ff', 'user', 0, 1), new Player('#ff5050', 'inactive', 7 - 1, 2), new Player('#ff9900', 'inactive', Math.pow(7, 2) - 7, 3), new Player('#009900', 'robot', Math.pow(7, 2) - 1, 4) ]; const playerIconIds = { human: '#human-player', ai: '#ai-player', none: '#no-player' }; const gameOverModal = getElementById('game-over-indicator'); const boardCells = []; const circleTmpl = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); let idsOfActivePlayers; let turn; circleTmpl.setAttribute('r', '13'); for(let i = 1; i <= 7; i += 1){ for(let j = 1; j <= 7; j += 1){ const circle = circleTmpl.cloneNode(true); circle.setAttribute('cx', 32 * j); circle.setAttribute('cy', 32 * i); boardCells.push(circle); } } boardObject.append(...boardCells); players.forEach(changePlayerRole); startBtn.addEventListener('click', ()=>{ if (!mainClassList.contains('game-is-running')) { startBtn.textContent = 'Restart Game'; mainClassList.add('game-is-running'); } idsOfActivePlayers = players.reduce((ids, player)=>{ if (player.state !== 'inactive') { ids.push(player.playerId); } return ids; }, []); turn = 0; setBoard(); }); function resetBoard() { startBtn.textContent = 'Start Game'; mainClassList.remove('game-is-running'); clearBoard(); players.forEach((p)=>p.roleChangeButton.classList.remove('active')); turn = undefined; } function Player(color, state, start, playerId) { return { color, state, start, playerId, pieces: [], roleChangeButton: getElementById(`plr${playerId}`) }; } function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } function getMoves(piece) { const isPieceNotAtLBorder = piece % 7 > 0; const isPieceNotAtRBorder = piece % 7 < 6; const isPieceNotByLBorder = piece % 7 > 1; const isPieceNotByRBorder = piece % 7 < 5; const neighborCells = [ isPieceNotAtLBorder ? piece - 1 : -1, isPieceNotAtLBorder ? piece - 7 - 1 : -1, isPieceNotAtLBorder ? piece + 7 - 1 : -1, piece - 7, isPieceNotAtRBorder ? piece - 7 + 1 : -1, isPieceNotAtRBorder ? piece + 1 : -1, isPieceNotAtRBorder ? piece + 7 + 1 : -1, piece + 7 ]; const cellsOneOff = [ isPieceNotAtLBorder && isPieceNotByLBorder ? piece - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? piece - 7 - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? piece - 2 * 7 - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? piece + 2 * 7 - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? piece + 7 - 2 : -1, isPieceNotAtLBorder ? piece - 2 * 7 - 1 : -1, isPieceNotAtLBorder ? piece + 2 * 7 - 1 : -1, piece - 2 * 7, piece + 2 * 7, isPieceNotAtRBorder && isPieceNotByRBorder ? piece - 2 * 7 + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? piece - 7 + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? piece + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? piece + 7 + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? piece + 2 * 7 + 2 : -1, isPieceNotAtRBorder ? piece - 2 * 7 + 1 : -1, isPieceNotAtRBorder ? piece + 2 * 7 + 1 : -1 ]; const nextTo = neighborCells.filter(findFreeCells); const oneOff = cellsOneOff.filter(findFreeCells); return { nextTo, oneOff }; } function findFreeCells(val) { return 0 <= val && val < board.length && board[val] === 0; } function getEnemyNeighbors(piece) { const isPieceNotAtLBorder = piece % 7 > 0; const isPieceNotAtRBorder = piece % 7 < 6; const neighborCells = [ isPieceNotAtLBorder ? piece - 1 : -1, isPieceNotAtLBorder ? piece - 7 - 1 : -1, isPieceNotAtLBorder ? piece + 7 - 1 : -1, piece - 7, isPieceNotAtRBorder ? piece - 7 + 1 : -1, isPieceNotAtRBorder ? piece + 1 : -1, isPieceNotAtRBorder ? piece + 7 + 1 : -1, piece + 7 ]; return neighborCells.filter((cell)=>0 <= cell && cell < board.length && board[cell] !== 0 && board[cell] !== idsOfActivePlayers[turn]); } function clearCell(cellIndex) { board[cellIndex] = 0; boardCells[cellIndex].style.fill = 'beige'; boardCells[cellIndex].classList = ''; boardCells[cellIndex].onclick = null; } function clearBoard() { gameOverModal.classList.remove('visible'); players.forEach((plr)=>{ plr.pieces.length = 0; plr.roleChangeButton.children[1].textContent = ''; }); boardCells.forEach((_, i)=>clearCell(i)); } function getPlaceStr(i) { switch(i){ case 0: return '1st'; case 1: return '2nd'; case 2: return '3rd'; case 3: return '4th'; } } function endTurn() { if (turn === undefined) { resetBoard(); return; } players[idsOfActivePlayers[turn] - 1].roleChangeButton.classList.remove('active'); if (turn < idsOfActivePlayers.length - 1) { turn += 1; } else { turn = 0; } idsOfActivePlayers.forEach((playerId)=>{ const player = players[playerId - 1]; player.roleChangeButton.children[1].textContent = player.pieces.length; }); if (board.filter((cell)=>cell === 0).length === 0 || players.filter((player)=>player.pieces.length > 0).length <= 1) { idsOfActivePlayers.map((id)=>({ playerId: id, pieces: players[id - 1].pieces.length })).sort(({ pieces: a }, { pieces: b })=>b - a).forEach(({ playerId }, i)=>{ players[playerId - 1].roleChangeButton.children[1].textContent = getPlaceStr(i); }); gameOverModal.classList.add('visible'); document.querySelector('main').classList.remove('game-is-running'); } else { move(); } } function humanMove(possibleMoves) { const plr = players[idsOfActivePlayers[turn] - 1]; possibleMoves.forEach((option)=>{ boardCells[option.piece].style.cursor = 'pointer'; boardCells[option.piece].onclick = ()=>{ if (boardCells[option.piece].classList.contains('selected')) { boardCells[option.piece].classList.remove('selected'); humanMove(possibleMoves); [ ...option.moves.nextTo, ...option.moves.oneOff ].forEach((e)=>{ boardCells[e].onclick = null; boardCells[e].style.cursor = 'initial'; }); } else { const helper = (e)=>{ [ ...option.moves.nextTo, ...option.moves.oneOff ].forEach((e2)=>{ boardCells[e2].onclick = null; boardCells[e2].style.cursor = 'initial'; }); board[e] = idsOfActivePlayers[turn]; boardCells[e].style.fill = plr.color; getEnemyNeighbors(e).forEach((gained)=>{ const owner = players[board[gained] - 1]; plr.pieces.push(...owner.pieces.splice(owner.pieces.indexOf(gained), 1)); board[gained] = idsOfActivePlayers[turn]; boardCells[gained].style.fill = plr.color; }); endTurn(); }; boardCells[option.piece].classList.add('selected'); plr.pieces.forEach((j)=>{ if (j !== option.piece) { boardCells[j].onclick = null; boardCells[j].style.cursor = 'initial'; } }); option.moves.nextTo.forEach((e)=>{ boardCells[e].style.cursor = 'pointer'; boardCells[e].onclick = ()=>{ boardCells[option.piece].onclick = null; boardCells[option.piece].classList = ''; boardCells[option.piece].style.cursor = 'initial'; plr.pieces.push(e); helper(e); }; }); option.moves.oneOff.forEach((e)=>{ boardCells[e].style.cursor = 'pointer'; boardCells[e].onclick = ()=>{ clearCell(option.piece); boardCells[option.piece].style.cursor = 'initial'; plr.pieces[plr.pieces.indexOf(option.piece)] = e; helper(e); }; }); } }; }); } function wait(ms) { return new Promise((r)=>setTimeout(r, ms)); } async function machineMove(possibleMoves) { const plr = players[idsOfActivePlayers[turn] - 1]; const payoffs = []; let most = [ 0, [] ]; let secMost = []; let thrdMost; let candidates; possibleMoves.forEach((o)=>{ payoffs.push({ next: o.moves.nextTo.map((closeNeighbor)=>({ origin: o.piece, target: closeNeighbor, bounty: getEnemyNeighbors(closeNeighbor), type: 1 })), oneOff: o.moves.oneOff.map((farNeighbor)=>({ origin: o.piece, target: farNeighbor, bounty: getEnemyNeighbors(farNeighbor), type: 0 })) }); }); payoffs.forEach((o)=>{ [ ...o.next, ...o.oneOff ].forEach((n)=>{ if (most[0] < n.bounty.length + n.type) { thrdMost = secMost.slice(); secMost = most.slice(); most = [ n.bounty.length + n.type, [ n ] ]; } else if (most[0] > n.bounty.length + n.type) { if (secMost[0] < n.bounty.length + n.type) { thrdMost = secMost.slice(); secMost = [ n.bounty.length + n.type, [ n ] ]; } else if (secMost[0] > n.bounty.length + n.type) { if (thrdMost[0] < n.bounty.length + n.type) { thrdMost = [ n.bounty.length + n.type, [ n ] ]; } else if (thrdMost[0] === n.bounty.length + n.type) { thrdMost[1].push(n); } } else if (secMost[0] === n.bounty.length + n.type) { secMost[1].push(n); } } else if (most[0] === n.bounty.length + n.type) most[1].push(n); }); }); if (secMost[0] === 0) { candidates = most; } else if (secMost[0] !== 0 && thrdMost[0] === 0) { const dice = Math.random(); if (dice > 0.1) candidates = most; else candidates = secMost; } else { const dice1 = Math.random(); if (dice1 > 0.1) candidates = most; else if (dice1 > 0.01) candidates = secMost; else candidates = thrdMost; } const id = getRandomInt(0, candidates[1].length - 1); const move = candidates[1][id]; await wait(200); boardCells[move.origin].classList.add('selected'); await wait(400); boardCells[move.target].style.stroke = 'Yellow'; await wait(500); [ move.target, ...move.bounty ].forEach((cell)=>{ if (board[cell] === 0) plr.pieces.push(cell); else { const owner = players[board[cell] - 1]; plr.pieces.push(...owner.pieces.splice(owner.pieces.indexOf(cell), 1)); } board[cell] = idsOfActivePlayers[turn]; boardCells[cell].style.fill = plr.color; }); await wait(200); boardCells[move.origin].classList.remove('selected'); boardCells[move.target].style.stroke = 'black'; if (move.type === 0) { clearCell(move.origin); plr.pieces.splice(plr.pieces.indexOf(move.origin), 1); } endTurn(); } function move() { if (turn === undefined) return; const plr = players[idsOfActivePlayers[turn] - 1]; const possibleMoves = plr.pieces.map((piece)=>({ piece: piece, moves: getMoves(piece) })).filter((option)=>option.moves.nextTo.length > 0 || option.moves.oneOff.length > 0); plr.roleChangeButton.classList.add('active'); if (possibleMoves.length === 0) { endTurn(); } else if (plr.state === 'user') { humanMove(possibleMoves); } else if (plr.state === 'robot') { machineMove(possibleMoves); } } function setBoard() { if (idsOfActivePlayers.length < 2) return; clearBoard(); idsOfActivePlayers.forEach((idOfActivePlayer)=>{ const player = players[idOfActivePlayer - 1]; boardCells[player.start].style.fill = player.color; board[player.start] = idOfActivePlayer; player.pieces.push(player.start); player.roleChangeButton.children[1].textContent = player.pieces.length; }); move(); } function changePlayerRole(player) { const roleChangeButton = player.roleChangeButton; roleChangeButton.onclick = ()=>{ if (mainClassList.contains('game-is-running')) { resetBoard(); } switch(player.state){ case 'inactive': roleChangeButton.children[0].firstElementChild.setAttribute('href', playerIconIds.ai); player.state = 'robot'; break; case 'robot': roleChangeButton.children[0].firstElementChild.setAttribute('href', playerIconIds.human); player.state = 'user'; break; case 'user': roleChangeButton.children[0].firstElementChild.setAttribute('href', playerIconIds.none); player.state = 'inactive'; break; } }; } }, { once: true });