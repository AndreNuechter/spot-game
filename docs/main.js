window.addEventListener('DOMContentLoaded', ()=>{ if ('serviceWorker' in window.navigator) { window.navigator.serviceWorker.register('./service-worker.js'); } }, { once: true }); if ('wakeLock' in navigator && 'request' in navigator.wakeLock) { const getWakeLock = ()=>navigator.wakeLock.request('screen'); getWakeLock(); document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'visible') { getWakeLock(); } }); } const cellCount = Math.pow(7, 2); const cssClasses = { activePlayer: 'active', clickableCell: 'clickable', disabledCell: 'disabled', gameIsRunning: 'game-is-running', highlightedTargetCell: 'targeted', selectedForMove: 'selected', visible: 'visible' }; const playerTypeIconIds = { human: '#human-player', robot: '#ai-player', inactive: '#no-player' }; const robotMoveDelays = { highlightStart: 300, highlightEnd: 500, makeMove: 700, finalize: 200 }; const playerRoleTransitions = { inactive: 'robot', robot: 'human', human: 'inactive' }; const gameOverModal = document.getElementById('game-over-indicator'); const documentStyles = getComputedStyle(document.documentElement); const mainClassList = document.querySelector('main').classList; const startBtn = document.getElementById('start'); const boardCells = []; const circleTmpl = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); circleTmpl.setAttribute('r', '16'); for(let i = 0; i < 7; i += 1){ for(let j = 0; j < 7; j += 1){ const circle = circleTmpl.cloneNode(true); circle.setAttribute('cx', 36 * j + 36 * 0.5); circle.setAttribute('cy', 36 * i + 36 * 0.5); boardCells.push(circle); } } document.getElementById('board').append(...boardCells); function CalculatedMove(origin, target, bounty, type) { return { origin, target, bounty, type }; } function getPlaceStr(place) { switch(place){ case 0: return '1st'; case 1: return '2nd'; case 2: return '3rd'; case 3: return '4th'; } } function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } function Player(color, controllerType, startPosition, playerId) { return { color, controllerType, startPosition, playerId, pieces: [], roleChangeButton: document.getElementById(`plr${playerId}`) }; } const players = [ Player(documentStyles.getPropertyValue('--player-1-color'), 'human', 0, 1), Player(documentStyles.getPropertyValue('--player-2-color'), 'inactive', 7 - 1, 2), Player(documentStyles.getPropertyValue('--player-3-color'), 'inactive', cellCount - 7, 3), Player(documentStyles.getPropertyValue('--player-4-color'), 'robot', cellCount - 1, 4) ]; let idsOfActivePlayers = []; function updateActivePlayers() { idsOfActivePlayers = players.reduce((ids, player)=>{ if (player.controllerType !== 'inactive') { ids.push(player.playerId); } return ids; }, []); } function updatePieceCount(player) { setPlayerSelectButtonText(player, player.pieces.length); } function setPlayerSelectButtonText(player, text) { player.roleChangeButton.children[1].textContent = text; } function setPlayerRole(player, newRole) { player.controllerType = newRole; player.roleChangeButton.children[0].firstElementChild.setAttribute('href', playerTypeIconIds[newRole]); } const board = new Array(cellCount).fill(0); function clearCell(cellId) { board[cellId] = 0; boardCells[cellId].dataset.ownerId = ''; boardCells[cellId].classList = ''; } let animationRequestId; function stopAnimation() { cancelAnimationFrame(animationRequestId); } function startAnimation(action) { animationRequestId = requestAnimationFrame(action); } function getPossibleMoves(pieceId) { const isPieceNotAtLBorder = pieceId % 7 > 0; const isPieceNotAtRBorder = pieceId % 7 < 6; const isPieceNotByLBorder = pieceId % 7 > 1; const isPieceNotByRBorder = pieceId % 7 < 5; const neighborCells = [ isPieceNotAtLBorder ? pieceId - 1 : -1, isPieceNotAtLBorder ? pieceId - 7 - 1 : -1, isPieceNotAtLBorder ? pieceId + 7 - 1 : -1, pieceId - 7, isPieceNotAtRBorder ? pieceId - 7 + 1 : -1, isPieceNotAtRBorder ? pieceId + 1 : -1, isPieceNotAtRBorder ? pieceId + 7 + 1 : -1, pieceId + 7 ]; const cellsOneOff = [ isPieceNotAtLBorder && isPieceNotByLBorder ? pieceId - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? pieceId - 7 - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? pieceId - 2 * 7 - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? pieceId + 2 * 7 - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? pieceId + 7 - 2 : -1, isPieceNotAtLBorder ? pieceId - 2 * 7 - 1 : -1, isPieceNotAtLBorder ? pieceId + 2 * 7 - 1 : -1, pieceId - 2 * 7, pieceId + 2 * 7, isPieceNotAtRBorder && isPieceNotByRBorder ? pieceId - 2 * 7 + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? pieceId - 7 + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? pieceId + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? pieceId + 7 + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? pieceId + 2 * 7 + 2 : -1, isPieceNotAtRBorder ? pieceId - 2 * 7 + 1 : -1, isPieceNotAtRBorder ? pieceId + 2 * 7 + 1 : -1 ]; const nextTo = neighborCells.filter(findValidMoveTargets); const oneOff = cellsOneOff.filter(findValidMoveTargets); return { nextTo, oneOff }; } function findValidMoveTargets(cellId) { return cellId >= 0 && cellId < board.length && board[cellId] === 0; } let turn = 0; const abortControllers = { selectMovablePiece: new AbortController(), selectReachableFreeCell: new AbortController() }; function getEnemyNeighbors(cellId) { const isPieceNotAtLBorder = cellId % 7 > 0; const isPieceNotAtRBorder = cellId % 7 < 6; const neighborCells = [ isPieceNotAtLBorder ? cellId - 1 : -1, isPieceNotAtLBorder ? cellId - 7 - 1 : -1, isPieceNotAtLBorder ? cellId + 7 - 1 : -1, cellId - 7, isPieceNotAtRBorder ? cellId - 7 + 1 : -1, isPieceNotAtRBorder ? cellId + 1 : -1, isPieceNotAtRBorder ? cellId + 7 + 1 : -1, cellId + 7 ]; return neighborCells.filter((cell)=>cell >= 0 && cell < board.length && ![ 0, idsOfActivePlayers[turn] ].includes(board[cell])); } function robotMove(possibleMoves) { const player = players[idsOfActivePlayers[turn] - 1]; const payoffs = possibleMoves.map((possibleMove)=>({ nextTo: possibleMove.moves.nextTo.map((closeNeighbor)=>CalculatedMove(possibleMove.pieceId, closeNeighbor, getEnemyNeighbors(closeNeighbor), 1)), oneOff: possibleMove.moves.oneOff.map((farNeighbor)=>CalculatedMove(possibleMove.pieceId, farNeighbor, getEnemyNeighbors(farNeighbor), 0)) })); let highestPayoff = [ 0, [] ]; let secondHighestPayoff = []; let thirdHighestPayoff; let bestMoves; payoffs.forEach((payoff)=>{ [ ...payoff.nextTo, ...payoff.oneOff ].forEach((move)=>{ const totalPayoff = move.bounty.length + move.type; if (highestPayoff[0] < totalPayoff) { thirdHighestPayoff = secondHighestPayoff.slice(); secondHighestPayoff = highestPayoff.slice(); highestPayoff = [ totalPayoff, [ move ] ]; } else if (highestPayoff[0] > totalPayoff) { if (secondHighestPayoff[0] < totalPayoff) { thirdHighestPayoff = secondHighestPayoff.slice(); secondHighestPayoff = [ totalPayoff, [ move ] ]; } else if (secondHighestPayoff[0] > totalPayoff) { if (thirdHighestPayoff[0] < totalPayoff) { thirdHighestPayoff = [ totalPayoff, [ move ] ]; } else if (thirdHighestPayoff[0] === totalPayoff) { thirdHighestPayoff[1].push(move); } } else if (secondHighestPayoff[0] === totalPayoff) { secondHighestPayoff[1].push(move); } } else { highestPayoff[1].push(move); } }); }); if (secondHighestPayoff[0] === 0) { bestMoves = highestPayoff; } else if (thirdHighestPayoff[0] === 0) { if (Math.random() > 0.1) { bestMoves = highestPayoff; } else { bestMoves = secondHighestPayoff; } } else { const diceRoll = Math.random(); if (diceRoll > 0.1) { bestMoves = highestPayoff; } else if (diceRoll > 0.01) { bestMoves = secondHighestPayoff; } else { bestMoves = thirdHighestPayoff; } } const move = bestMoves[1][getRandomInt(0, bestMoves[1].length - 1)]; const movablePieceChosenAt = performance.now() + robotMoveDelays.highlightStart; const targetCellChosenAt = movablePieceChosenAt + robotMoveDelays.highlightEnd; const moveMadeAt = targetCellChosenAt + robotMoveDelays.finalize; const turnEndedAt = moveMadeAt + robotMoveDelays.finalize; const finalizeMove = partialRobotMove(turnEndedAt, ()=>{ if (move.type === 0) { clearCell(move.origin); player.pieces.splice(player.pieces.indexOf(move.origin), 1); } boardCells[move.origin].classList.remove(cssClasses.selectedForMove); boardCells[move.target].classList.remove(cssClasses.highlightedTargetCell); }, endTurn); const makeMove = partialRobotMove(moveMadeAt, ()=>{ [ move.target, ...move.bounty ].forEach((cellId)=>{ if (board[cellId] === 0) { player.pieces.push(cellId); } else { const owner = players[board[cellId] - 1]; player.pieces.push(...owner.pieces.splice(owner.pieces.indexOf(cellId), 1)); } board[cellId] = player.playerId; boardCells[cellId].dataset.ownerId = player.playerId; }); }, finalizeMove); const highlightSelectedCell = partialRobotMove(targetCellChosenAt, ()=>boardCells[move.target].classList.add(cssClasses.highlightedTargetCell), makeMove); const highlightSelectedPiece = partialRobotMove(movablePieceChosenAt, ()=>boardCells[move.origin].classList.add(cssClasses.selectedForMove), highlightSelectedCell); startAnimation(highlightSelectedPiece); } function resetTurn() { turn = 0; } function incrementTurn() { if (turn < idsOfActivePlayers.length - 1) { turn += 1; } else { resetTurn(); } } function endTurn() { players[idsOfActivePlayers[turn] - 1].roleChangeButton.classList.remove(cssClasses.activePlayer); idsOfActivePlayers.forEach((playerId)=>updatePieceCount(players[playerId - 1])); if (board.find((cell)=>cell === 0) === undefined || players.filter((player)=>player.pieces.length > 0).length === 1) { idsOfActivePlayers.map((playerId)=>({ playerId, pieceCount: players[playerId - 1].pieces.length })).sort(({ pieceCount: a }, { pieceCount: b })=>b - a).forEach(({ playerId }, i)=>setPlayerSelectButtonText(players[playerId - 1], getPlaceStr(i))); gameOverModal.classList.add(cssClasses.visible); mainClassList.remove(cssClasses.gameIsRunning); } else { incrementTurn(); takeTurn(); } } function resetAbortControllers() { Object.assign(abortControllers, { selectMovablePiece: new AbortController(), selectReachableFreeCell: new AbortController() }); } function disableHumanInput() { abortControllers.selectMovablePiece.abort(); abortControllers.selectReachableFreeCell.abort(); } function humanMove(possibleMoves) { const player = players[idsOfActivePlayers[turn] - 1]; resetAbortControllers(); possibleMoves.forEach((possibleMove)=>{ const movablePiece = boardCells[possibleMove.pieceId]; movablePiece.classList.add(cssClasses.clickableCell); movablePiece.addEventListener('click', ({ target: { classList: classListOfClickedPiece } })=>{ if (classListOfClickedPiece.contains(cssClasses.selectedForMove)) { classListOfClickedPiece.remove(cssClasses.selectedForMove); removeHighlightFromTargetCells(possibleMove); abortControllers.selectReachableFreeCell.abort(); possibleMoves.forEach(({ pieceId })=>boardCells[pieceId].classList.replace(cssClasses.disabledCell, cssClasses.clickableCell)); } else { abortControllers.selectReachableFreeCell = new AbortController(); classListOfClickedPiece.add(cssClasses.selectedForMove); player.pieces.filter((cellId)=>cellId !== possibleMove.pieceId).forEach((cellId)=>boardCells[cellId].classList.replace(cssClasses.clickableCell, cssClasses.disabledCell)); possibleMove.moves.nextTo.forEach((cellId)=>{ boardCells[cellId].classList.add(cssClasses.clickableCell); boardCells[cellId].addEventListener('click', ()=>{ player.pieces.push(cellId); finalizeMoveToCell(player, cellId, possibleMoves, possibleMove); }, { signal: abortControllers.selectReachableFreeCell.signal }); }); possibleMove.moves.oneOff.forEach((cellId)=>{ boardCells[cellId].classList.add(cssClasses.clickableCell); boardCells[cellId].addEventListener('click', ()=>{ player.pieces[player.pieces.indexOf(possibleMove.pieceId)] = cellId; clearCell(possibleMove.pieceId); finalizeMoveToCell(player, cellId, possibleMoves, possibleMove); }, { signal: abortControllers.selectReachableFreeCell.signal }); }); } }, { signal: abortControllers.selectMovablePiece.signal }); }); } function takeTurn() { const player = players[idsOfActivePlayers[turn] - 1]; const possibleMoves = player.pieces.map((piece)=>({ pieceId: piece, moves: getPossibleMoves(piece) })).filter((option)=>option.moves.nextTo.length > 0 || option.moves.oneOff.length > 0); player.roleChangeButton.classList.add(cssClasses.activePlayer); if (possibleMoves.length === 0) { endTurn(); } else if (player.controllerType === 'human') { humanMove(possibleMoves); } else if (player.controllerType === 'robot') { robotMove(possibleMoves); } } function endGame() { mainClassList.remove(cssClasses.gameIsRunning); players.forEach((player)=>player.roleChangeButton.classList.remove(cssClasses.activePlayer)); disableHumanInput(); stopAnimation(); clearBoard(); } function startGame() { updateActivePlayers(); if (idsOfActivePlayers.length < 2) return; resetTurn(); clearBoard(); mainClassList.add(cssClasses.gameIsRunning); idsOfActivePlayers.forEach((idOfActivePlayer)=>{ const player = players[idOfActivePlayer - 1]; boardCells[player.startPosition].dataset.ownerId = player.playerId; board[player.startPosition] = player.playerId; player.pieces.push(player.startPosition); updatePieceCount(player); }); takeTurn(); } function clearBoard() { gameOverModal.classList.remove(cssClasses.visible); players.forEach((player)=>{ player.pieces.length = 0; setPlayerSelectButtonText(player, ''); }); boardCells.forEach((_, i)=>clearCell(i)); } function finalizeMoveToCell(player, idOfTargetCell, possibleMoves, chosenMove) { board[idOfTargetCell] = player.playerId; boardCells[idOfTargetCell].dataset.ownerId = player.playerId; getEnemyNeighbors(idOfTargetCell).forEach((idOfGainedPiece)=>{ const previousOwner = players[board[idOfGainedPiece] - 1]; player.pieces.push(...previousOwner.pieces.splice(previousOwner.pieces.indexOf(idOfGainedPiece), 1)); board[idOfGainedPiece] = player.playerId; boardCells[idOfGainedPiece].dataset.ownerId = player.playerId; }); disableHumanInput(); possibleMoves.forEach(({ pieceId })=>boardCells[pieceId].classList.remove(cssClasses.disabledCell, cssClasses.clickableCell, cssClasses.selectedForMove)); removeHighlightFromTargetCells(chosenMove); endTurn(); } function removeHighlightFromTargetCells({ moves: { nextTo , oneOff } }) { [ ...nextTo, ...oneOff ].forEach((cellId)=>boardCells[cellId].classList.remove(cssClasses.clickableCell)); } function partialRobotMove(scheduledTime, action, nextStep) { const currentStep = (timestamp)=>{ if (timestamp >= scheduledTime) { action(); startAnimation(nextStep); } else { startAnimation(currentStep); } }; return currentStep; } players.forEach((player)=>player.roleChangeButton.addEventListener('click', ()=>{ if (mainClassList.contains(cssClasses.gameIsRunning)) { endGame(); } setPlayerRole(player, playerRoleTransitions[player.controllerType]); })); startBtn.addEventListener('click', ()=>{ if (mainClassList.contains(cssClasses.gameIsRunning)) { endGame(); } startGame(); });