window.addEventListener('DOMContentLoaded', ()=>{ if ('serviceWorker' in window.navigator) { window.navigator.serviceWorker.register('./service-worker.js'); } }, { once: true }); if ('wakeLock' in navigator && 'request' in navigator.wakeLock) { const getWakeLock = ()=>navigator.wakeLock.request('screen'); getWakeLock(); document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'visible') { getWakeLock(); } }); } const cellCount = Math.pow(7, 2); const cssClasses = { activePlayer: 'active', clickableCell: 'clickable', disabledCell: 'disabled', gameIsRunning: 'game-is-running', highlightedTargetCell: 'targeted', selectedForMove: 'selected', visible: 'visible' }; const playerTypeIconIds = { human: '#human-player', robot: '#ai-player', inactive: '#no-player' }; const gameOverModal = document.getElementById('game-over-indicator'); const documentStyles = getComputedStyle(document.documentElement); const mainClassList = document.querySelector('main').classList; const startBtn = document.getElementById('start'); const boardCells = []; const circleTmpl = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); circleTmpl.setAttribute('r', '16'); for(let i = 0; i < 7; i += 1){ for(let j = 0; j < 7; j += 1){ const circle = circleTmpl.cloneNode(true); circle.setAttribute('cx', 36 * j + 36 * 0.5); circle.setAttribute('cy', 36 * i + 36 * 0.5); boardCells.push(circle); } } document.getElementById('board').append(...boardCells); function CalculatedMove(origin, target, bounty, type) { return { origin, target, bounty, type }; } function getPlaceStr(place) { switch(place){ case 0: return '1st'; case 1: return '2nd'; case 2: return '3rd'; case 3: return '4th'; } } function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } function Player(color, controllerType, startPosition, playerId) { return { color, controllerType, startPosition, playerId, pieces: [], roleChangeButton: document.getElementById(`plr${playerId}`) }; } function wait(ms) { return new Promise((r)=>setTimeout(r, ms)); } const board = new Array(cellCount).fill(0); const players = [ new Player(documentStyles.getPropertyValue('--player-1-color'), 'human', 0, 1), new Player(documentStyles.getPropertyValue('--player-2-color'), 'inactive', 7 - 1, 2), new Player(documentStyles.getPropertyValue('--player-3-color'), 'inactive', cellCount - 7, 3), new Player(documentStyles.getPropertyValue('--player-4-color'), 'robot', cellCount - 1, 4) ]; const abortControllers = { selectMovablePiece: new AbortController(), selectReachableFreeCell: new AbortController(), computerMove: new AbortController() }; let turn = 0; let idsOfActivePlayers = []; players.forEach((player)=>player.roleChangeButton.addEventListener('click', ()=>{ if (mainClassList.contains(cssClasses.gameIsRunning)) { endGame(); startBtn.textContent = 'Start Game'; } switch(player.controllerType){ case 'inactive': setPlayerRole(player, 'robot'); break; case 'robot': setPlayerRole(player, 'human'); break; case 'human': setPlayerRole(player, 'inactive'); break; } })); startBtn.addEventListener('click', ()=>{ idsOfActivePlayers = players.reduce((ids, player)=>{ if (player.controllerType !== 'inactive') { ids.push(player.playerId); } return ids; }, []); if (idsOfActivePlayers.length < 2) return; if (mainClassList.contains(cssClasses.gameIsRunning)) { endGame(); } else { startBtn.textContent = 'Restart Game'; mainClassList.add(cssClasses.gameIsRunning); } startGame(); }); function endGame() { turn = 0; mainClassList.remove(cssClasses.gameIsRunning); players.forEach((player)=>player.roleChangeButton.classList.remove(cssClasses.activePlayer)); clearBoard(); } function startGame() { clearBoard(); idsOfActivePlayers.forEach((idOfActivePlayer)=>{ const player = players[idOfActivePlayer - 1]; boardCells[player.startPosition].dataset.ownerId = player.playerId; board[player.startPosition] = player.playerId; player.pieces.push(player.startPosition); updatePieceCount(player); }); abortControllers.computerMove = new AbortController(); makeMove(); } function setPlayerRole(player, newRole) { player.controllerType = newRole; player.roleChangeButton.children[0].firstElementChild.setAttribute('href', playerTypeIconIds[newRole]); } function updatePieceCount(player) { setPlayerSelectButtonText(player, player.pieces.length); } function setPlayerSelectButtonText(player, text) { player.roleChangeButton.children[1].textContent = text; } function clearBoard() { gameOverModal.classList.remove(cssClasses.visible); players.forEach((player)=>{ player.pieces.length = 0; setPlayerSelectButtonText(player, ''); }); abortControllers.selectMovablePiece.abort(); abortControllers.selectReachableFreeCell.abort(); abortControllers.computerMove.abort(); boardCells.forEach((_, i)=>clearCell(i)); } function clearCell(cellId) { board[cellId] = 0; boardCells[cellId].dataset.ownerId = ''; boardCells[cellId].classList = ''; } function makeMove() { if (abortControllers.computerMove.signal.aborted) { return; } const player = players[idsOfActivePlayers[turn] - 1]; const possibleMoves = player.pieces.map((piece)=>({ pieceId: piece, moves: getPossibleMoves(piece) })).filter((option)=>option.moves.nextTo.length > 0 || option.moves.oneOff.length > 0); player.roleChangeButton.classList.add(cssClasses.activePlayer); if (possibleMoves.length === 0) { endTurn(); } else if (player.controllerType === 'human') { humanMove(possibleMoves); } else if (player.controllerType === 'robot') { machineMove(possibleMoves, abortControllers.computerMove.signal).then(endTurn); } } function getPossibleMoves(pieceId) { const isPieceNotAtLBorder = pieceId % 7 > 0; const isPieceNotAtRBorder = pieceId % 7 < 6; const isPieceNotByLBorder = pieceId % 7 > 1; const isPieceNotByRBorder = pieceId % 7 < 5; const neighborCells = [ isPieceNotAtLBorder ? pieceId - 1 : -1, isPieceNotAtLBorder ? pieceId - 7 - 1 : -1, isPieceNotAtLBorder ? pieceId + 7 - 1 : -1, pieceId - 7, isPieceNotAtRBorder ? pieceId - 7 + 1 : -1, isPieceNotAtRBorder ? pieceId + 1 : -1, isPieceNotAtRBorder ? pieceId + 7 + 1 : -1, pieceId + 7 ]; const cellsOneOff = [ isPieceNotAtLBorder && isPieceNotByLBorder ? pieceId - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? pieceId - 7 - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? pieceId - 2 * 7 - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? pieceId + 2 * 7 - 2 : -1, isPieceNotAtLBorder && isPieceNotByLBorder ? pieceId + 7 - 2 : -1, isPieceNotAtLBorder ? pieceId - 2 * 7 - 1 : -1, isPieceNotAtLBorder ? pieceId + 2 * 7 - 1 : -1, pieceId - 2 * 7, pieceId + 2 * 7, isPieceNotAtRBorder && isPieceNotByRBorder ? pieceId - 2 * 7 + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? pieceId - 7 + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? pieceId + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? pieceId + 7 + 2 : -1, isPieceNotAtRBorder && isPieceNotByRBorder ? pieceId + 2 * 7 + 2 : -1, isPieceNotAtRBorder ? pieceId - 2 * 7 + 1 : -1, isPieceNotAtRBorder ? pieceId + 2 * 7 + 1 : -1 ]; const nextTo = neighborCells.filter(findFreeCells); const oneOff = cellsOneOff.filter(findFreeCells); return { nextTo, oneOff }; } function endTurn() { if (abortControllers.computerMove.signal.aborted) { return; } players[idsOfActivePlayers[turn] - 1].roleChangeButton.classList.remove(cssClasses.activePlayer); idsOfActivePlayers.forEach((playerId)=>updatePieceCount(players[playerId - 1])); if (board.find((cell)=>cell === 0) === undefined || players.filter((player)=>player.pieces.length > 0).length === 1) { idsOfActivePlayers.map((playerId)=>({ playerId, pieceCount: players[playerId - 1].pieces.length })).sort(({ pieceCount: a }, { pieceCount: b })=>b - a).forEach(({ playerId }, i)=>setPlayerSelectButtonText(players[playerId - 1], getPlaceStr(i))); gameOverModal.classList.add(cssClasses.visible); mainClassList.remove(cssClasses.gameIsRunning); } else { if (turn < idsOfActivePlayers.length - 1) { turn += 1; } else { turn = 0; } makeMove(); } } function humanMove(possibleMoves) { const player = players[idsOfActivePlayers[turn] - 1]; Object.assign(abortControllers, { selectMovablePiece: new AbortController(), selectReachableFreeCell: new AbortController() }); possibleMoves.forEach((possibleMove)=>{ const movableCell = boardCells[possibleMove.pieceId]; movableCell.classList.add(cssClasses.clickableCell); movableCell.addEventListener('click', ({ target: { classList: classListOfClickedPiece } })=>{ if (classListOfClickedPiece.contains(cssClasses.selectedForMove)) { classListOfClickedPiece.remove(cssClasses.selectedForMove); removeHighlightFromTargetCells(possibleMove); possibleMoves.forEach((possibleMove)=>boardCells[possibleMove.pieceId].classList.replace(cssClasses.disabledCell, cssClasses.clickableCell)); } else { const finalizeMoveToCell = (idOfTargetCell)=>{ board[idOfTargetCell] = player.playerId; boardCells[idOfTargetCell].dataset.ownerId = player.playerId; getEnemyNeighbors(idOfTargetCell).forEach((idOfGainedPiece)=>{ const previousOwner = players[board[idOfGainedPiece] - 1]; player.pieces.push(...previousOwner.pieces.splice(previousOwner.pieces.indexOf(idOfGainedPiece), 1)); board[idOfGainedPiece] = player.playerId; boardCells[idOfGainedPiece].dataset.ownerId = player.playerId; }); abortControllers.selectMovablePiece.abort(); abortControllers.selectReachableFreeCell.abort(); possibleMoves.forEach((possibleMove)=>boardCells[possibleMove.pieceId].classList.remove(cssClasses.disabledCell, cssClasses.clickableCell, cssClasses.selectedForMove)); removeHighlightFromTargetCells(possibleMove); endTurn(); }; classListOfClickedPiece.add(cssClasses.selectedForMove); player.pieces.filter((cellId)=>cellId !== possibleMove.pieceId).forEach((cellId)=>boardCells[cellId].classList.replace(cssClasses.clickableCell, cssClasses.disabledCell)); possibleMove.moves.nextTo.forEach((cellId)=>{ boardCells[cellId].classList.add(cssClasses.clickableCell); boardCells[cellId].addEventListener('click', ()=>{ player.pieces.push(cellId); finalizeMoveToCell(cellId); }, { signal: abortControllers.selectReachableFreeCell.signal }); }); possibleMove.moves.oneOff.forEach((cellId)=>{ boardCells[cellId].classList.add(cssClasses.clickableCell); boardCells[cellId].addEventListener('click', ()=>{ player.pieces[player.pieces.indexOf(possibleMove.pieceId)] = cellId; clearCell(possibleMove.pieceId); finalizeMoveToCell(cellId); }, { signal: abortControllers.selectReachableFreeCell.signal }); }); } }, { signal: abortControllers.selectMovablePiece.signal }); }); } async function machineMove(possibleMoves, abortSignal) { const player = players[idsOfActivePlayers[turn] - 1]; const payoffs = possibleMoves.map((possibleMove)=>({ nextTo: possibleMove.moves.nextTo.map((closeNeighbor)=>CalculatedMove(possibleMove.pieceId, closeNeighbor, getEnemyNeighbors(closeNeighbor), 1)), oneOff: possibleMove.moves.oneOff.map((farNeighbor)=>CalculatedMove(possibleMove.pieceId, farNeighbor, getEnemyNeighbors(farNeighbor), 0)) })); let highestPayoff = [ 0, [] ]; let secondHighestPayoff = []; let thirdHighestPayoff; let bestMoves; payoffs.forEach((payoff)=>{ [ ...payoff.nextTo, ...payoff.oneOff ].forEach((move)=>{ const totalPayoff = move.bounty.length + move.type; if (highestPayoff[0] < totalPayoff) { thirdHighestPayoff = secondHighestPayoff.slice(); secondHighestPayoff = highestPayoff.slice(); highestPayoff = [ totalPayoff, [ move ] ]; } else if (highestPayoff[0] > totalPayoff) { if (secondHighestPayoff[0] < totalPayoff) { thirdHighestPayoff = secondHighestPayoff.slice(); secondHighestPayoff = [ totalPayoff, [ move ] ]; } else if (secondHighestPayoff[0] > totalPayoff) { if (thirdHighestPayoff[0] < totalPayoff) { thirdHighestPayoff = [ totalPayoff, [ move ] ]; } else if (thirdHighestPayoff[0] === totalPayoff) { thirdHighestPayoff[1].push(move); } } else if (secondHighestPayoff[0] === totalPayoff) { secondHighestPayoff[1].push(move); } } else if (highestPayoff[0] === totalPayoff) { highestPayoff[1].push(move); } }); }); if (secondHighestPayoff[0] === 0) { bestMoves = highestPayoff; } else if (thirdHighestPayoff[0] === 0) { if (Math.random() > 0.1) { bestMoves = highestPayoff; } else { bestMoves = secondHighestPayoff; } } else { const diceRoll = Math.random(); if (diceRoll > 0.1) { bestMoves = highestPayoff; } else if (diceRoll > 0.01) { bestMoves = secondHighestPayoff; } else { bestMoves = thirdHighestPayoff; } } const id = getRandomInt(0, bestMoves[1].length - 1); const move = bestMoves[1][id]; await wait(200); if (abortSignal.aborted) { endGame(); return; } boardCells[move.origin].classList.add(cssClasses.selectedForMove); await wait(400); if (abortSignal.aborted) { endGame(); return; } boardCells[move.target].classList.add(cssClasses.highlightedTargetCell); await wait(500); if (abortSignal.aborted) { endGame(); return; } [ move.target, ...move.bounty ].forEach((cellId)=>{ if (board[cellId] === 0) player.pieces.push(cellId); else { const owner = players[board[cellId] - 1]; player.pieces.push(...owner.pieces.splice(owner.pieces.indexOf(cellId), 1)); } board[cellId] = player.playerId; boardCells[cellId].dataset.ownerId = player.playerId; }); await wait(200); if (abortSignal.aborted) { endGame(); return; } if (move.type === 0) { clearCell(move.origin); player.pieces.splice(player.pieces.indexOf(move.origin), 1); } boardCells[move.origin].classList.remove(cssClasses.selectedForMove); boardCells[move.target].classList.remove(cssClasses.highlightedTargetCell); } function findFreeCells(cellId) { return cellId >= 0 && cellId < board.length && board[cellId] === 0; } function getEnemyNeighbors(cellId) { const isPieceNotAtLBorder = cellId % 7 > 0; const isPieceNotAtRBorder = cellId % 7 < 6; const neighborCells = [ isPieceNotAtLBorder ? cellId - 1 : -1, isPieceNotAtLBorder ? cellId - 7 - 1 : -1, isPieceNotAtLBorder ? cellId + 7 - 1 : -1, cellId - 7, isPieceNotAtRBorder ? cellId - 7 + 1 : -1, isPieceNotAtRBorder ? cellId + 1 : -1, isPieceNotAtRBorder ? cellId + 7 + 1 : -1, cellId + 7 ]; return neighborCells.filter((cell)=>cell >= 0 && cell < board.length && board[cell] !== 0 && board[cell] !== idsOfActivePlayers[turn]); } function removeHighlightFromTargetCells({ moves: { nextTo , oneOff } }) { [ ...nextTo, ...oneOff ].forEach((cellId)=>boardCells[cellId].classList.remove(cssClasses.clickableCell)); }